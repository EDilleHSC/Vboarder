"""
VBoarder Unified API Server (v3)
Optimized for multi-agent coordination and nested agent discovery.
"""

import os
import json
import logging
import asyncio
from typing import List, Dict, Optional, Set

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, field_validator
from dotenv import load_dotenv

# ----------------------------------------------------------------------------- #
# Configuration
# ----------------------------------------------------------------------------- #
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(os.path.dirname(BASE_DIR))
load_dotenv()

APP_TITLE = "VBoarder Executive API"
API_PORT = int(os.getenv("API_PORT", 8000))
FRONTEND_PORT = int(os.getenv("FRONTEND_PORT", 5173))
RELOAD = os.getenv("RELOAD", "true").lower() == "true"
WORKERS = int(os.getenv("WORKERS", "1"))
QUERY_TIMEOUT = int(os.getenv("QUERY_TIMEOUT_SEC", "45"))

SCRIPT_PATH = os.path.join(BASE_DIR, "query_agent_memory.py")
AGENT_JSON = os.path.join(ROOT_DIR, "webui_agents.json")
AGENT_DIR = os.path.join(ROOT_DIR, "agents")

# ----------------------------------------------------------------------------- #
# Logging Setup
# ----------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logger = logging.getLogger("vboarder.api")

# ----------------------------------------------------------------------------- #
# Agent Discovery
# ----------------------------------------------------------------------------- #
def discover_agent_files(agent_dir: str) -> Dict[str, Optional[str]]:
    """Locate key files within an agent directory."""
    system_prompt, memory_file, persona_file = None, None, None

    # System prompt search paths
    for candidate in [
        "system.txt", "system_prompt.txt",
        "prompts/system.txt", "prompts/system_detailed.txt",
    ]:
        p = os.path.join(agent_dir, candidate)
        if os.path.exists(p):
            system_prompt = p
            break

    # Memory file search paths
    for candidate in ["memory.json", "memory/memory.json", "state/memory.json"]:
        p = os.path.join(agent_dir, candidate)
        if os.path.exists(p):
            memory_file = p
            break

    # Persona file
    persona_path = os.path.join(agent_dir, "personas", "vision.txt")
    if os.path.exists(persona_path):
        persona_file = persona_path

    return {
        "system_prompt": system_prompt,
        "memory": memory_file,
        "persona": persona_file,
    }


def load_agents() -> List[dict]:
    """Load agents from webui_agents.json or discover them automatically."""
    # Try structured agent registry first
    if os.path.exists(AGENT_JSON):
        try:
            with open(AGENT_JSON, "r", encoding="utf-8-sig") as f:
                data = json.load(f)
            logger.info(f"Loaded {len(data)} agents from webui_agents.json")
            return [
                {**a, "code": a.get("agent_name", a.get("code", "")).lower()}
                for a in data
            ]
        except Exception as e:
            logger.exception(f"Failed to read agent registry ({AGENT_JSON}): {e}")

    # Fallback: Auto-discover from folders
    agents = []
    if os.path.isdir(AGENT_DIR):
        for name in os.listdir(AGENT_DIR):
            path = os.path.join(AGENT_DIR, name)
            if not os.path.isdir(path):
                continue

            files = discover_agent_files(path)
            agent_data = {
                "code": name.lower(),
                "name": name.upper(),
                "system_prompt": files["system_prompt"],
                "memory": files["memory"],
                "persona": files["persona"],
                "path": path,
                "status": "active" if files["system_prompt"] else "incomplete",
            }
            agents.append(agent_data)
            logger.info(f"Discovered agent {name.upper()} -> {files}")

        logger.info(f"Auto-detected {len(agents)} agents from /agents folder.")
    else:
        logger.warning("No /agents directory found.")
    return agents


AGENTS = load_agents()
VALID_AGENTS: Set[str] = {a["code"] for a in AGENTS if a["status"] == "active"}

# ----------------------------------------------------------------------------- #
# FastAPI Init
# ----------------------------------------------------------------------------- #
app = FastAPI(title=APP_TITLE)

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        f"http://localhost:{FRONTEND_PORT}",
        "http://127.0.0.1:5173",
        "http://localhost:3000",
    ],
    allow_methods=["GET", "POST", "OPTIONS"],
    allow_headers=["*"],
    allow_credentials=True,
)

# ----------------------------------------------------------------------------- #
# Models
# ----------------------------------------------------------------------------- #
class ChatRequest(BaseModel):
    message: str = Field(..., description="User input message to the agent.")

    @field_validator("message")
    @classmethod
    def validate_message(cls, v: str) -> str:
        v = v.strip()
        if not v:
            raise ValueError("Message cannot be empty.")
        if len(v) > 8000:
            raise ValueError("Message too long (max 8000 chars).")
        return v


class ChatResponse(BaseModel):
    agent: str
    response: str


# ----------------------------------------------------------------------------- #
# Helpers
# ----------------------------------------------------------------------------- #
def assert_script_exists():
    if not os.path.isfile(SCRIPT_PATH):
        raise HTTPException(status_code=500, detail=f"Missing script: {SCRIPT_PATH}")


def parse_query_output(stdout: str) -> str:
    """Try JSON parsing first; fallback to plain text."""
    s = stdout.strip()
    if not s:
        return s
    try:
        data = json.loads(s)
        if isinstance(data, dict):
            for key in ("response", "answer", "result"):
                if key in data and isinstance(data[key], str):
                    return data[key].strip()
        return json.dumps(data)
    except Exception:
        pass

    delimiter = "=" * 70
    return s.split(delimiter)[-1].strip() if delimiter in s else s


async def run_query(agent: str, message: str) -> str:
    assert_script_exists()
    cmd = ["python", SCRIPT_PATH, agent, message]
    logger.info(f"Running agent query: agent={agent}, msg_len={len(message)}")

    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        try:
            stdout, stderr = await asyncio.wait_for(
                proc.communicate(), timeout=QUERY_TIMEOUT
            )
        except asyncio.TimeoutError:
            proc.kill()
            await proc.wait()
            logger.error(f"Query timed out for agent={agent}")
            raise HTTPException(status_code=504, detail="Query timed out.")

        if proc.returncode != 0:
            err = (stderr or b"").decode("utf-8", errors="replace")
            logger.error(f"Query script failed (code {proc.returncode}): {err}")
            raise HTTPException(status_code=500, detail="Query failed.")

        out = (stdout or b"").decode("utf-8", errors="replace")
        return parse_query_output(out)

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Unexpected error during query execution")
        raise HTTPException(status_code=500, detail="Internal server error.")


# ----------------------------------------------------------------------------- #
# Routes
# ----------------------------------------------------------------------------- #
@app.get("/health")
def health_check():
    return {"status": "ok", "agents": len(AGENTS)}


@app.get("/vboarder/agents")
def list_agents():
    """Return list of agents with their discovered files."""
    return AGENTS


@app.post("/vboarder/chat/{agent}", response_model=ChatResponse)
async def chat_agent(agent: str, req: ChatRequest):
    code = agent.lower()
    if code not in VALID_AGENTS:
        raise HTTPException(status_code=404, detail=f"Agent '{agent}' not found or inactive.")

    response_text = await run_query(code, req.message)
    return ChatResponse(agent=code, response=response_text)


@app.exception_handler(HTTPException)
async def handle_http_error(request: Request, exc: HTTPException):
    return JSONResponse(status_code=exc.status_code, content={"error": exc.detail})

# ----------------------------------------------------------------------------- #
# Entrypoint
# ----------------------------------------------------------------------------- #
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "api_server:app",
        host="0.0.0.0",
        port=API_PORT,
        reload=RELOAD and WORKERS == 1,
        workers=WORKERS if not RELOAD else 1,
        log_level="info",
        proxy_headers=True,
        forwarded_allow_ips="*",
    )